## DP 문제 해결 방법

DP 유형임을 파악하는것이 중요

1. 그리디, 구현, 완전탐색 등의 아이디어로 문제를 해결할 수 있는지 먼저 검토
2. 일단 **재귀함수로 비효율적인 완전탐색 프로그램을 작성**한 뒤에, 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, **메모이제이션 기법을 이용해 코드를 개선하는 방법**으로 수정
3. 일반적인 코테 수준에서는 **기본 유형의 DP문제가 출제**되는 경우가 많다고 함. DP문제는 점화식 떠오르는데 오래 걸리므로 코테에서는 좀 쉽게 나온다고 함!



##### DP 해결 스킬

1. 0번째부터 시작해서 i번째까지 오름차순으로 하나씩 포함해가면서, i번째 값을 i-1, i-2 번째 값을 이용하여 구하는 방식으로, 점화식을 구한다.
2. 특정값으로 배열을 채우고 업데이트 하는 방법 (ex. Arrays.fill)
3. 가장 긴 증가하는 부분수열 (LIS 알고리즘)
   가장 긴 증가하는 수열을 찾는 문제
   D[i] = max(D[i], D[j]+1) if array[j] < array[i]



##### DP 활용방법

실제 코테에서 DP에 해당하는 문제 풀이에 활용할 때 다음과 같은 방식으로 사용 *(항상 적용되는것은 아님!)*

1. 문제에서 요구하는 답을 **문장으로 표현**한다.
2. 문장에 나와있는 **변수 갯수만큼 메모이제이션을 위한 캐시 배열을 생성**한다.
3. 문제를 부분문제로 나누고, **점화식을 구하여** 문제를 함수로 표현한다.
4. top-down의 경우 **재귀함수**, bottom-up의 경우 **for문**을 활용하여 답을 도출한다.

이러한 동적계획법은 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식이라
이와 대비되는 그리디알고리즘(모든 해를 구하지 않고 순간마다 최적의 해를 찾는 알고리즘)과 이점을 잘 비교하여 문제에 적용해야한다.

- **DP**는 항상 최적의 해를 검출하지만 시간이 오래 걸리고
- **그리디 알고리즘**은 최적의 해가 아닐 수 있지만 시간이 짧게 걸리는 장,단점들을 서로 비교해야한다!



## 대표적인 DP문제 유형

### 막대 자르기

길이가 N인 막대기가 있다. 막대기를 길이가 자연수가 되도록 여러 조각으로 자를 수 있다.
막대기는 자르는 길이에 따라 값이 정해져 있다. 막대를 자르는 값어치의 합이 최대가 되게끔 막대기를 자르자.

| 길이(i)  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 가격(Pi) | 0    | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

ex) 4인 막대기를 자를 때 얻을 수 있는 최대 가격은, 길이가 2인 막대기 두개로 나누어서 가격을 5+5 =10으로 만들 수 있다
길이가 6인 막대기는 자르지 않고 그냥 팔았을 때 최대 17의 가격을 얻을 수 있다.

길이가 n인 막대기의 최대 가격을 Rn이라고 했을 때, **Rn = max(Pi+Rn-i) (i는 1~n)** 로 나타낼 수 있다. 
ex) n=4, R4 = max(P1+R3, P2+R2, P3+R1, P4+R0)이 된다. 

R1은 **Rn = max(Pi + Rn-i) (i는 1부터 n)** 식에서 max(P1 + R0)이므로 1입니다.
R2는 max(P1 + R1, P2 + R0)이라 max(2, 5) = 5
R3는 max(P1 + R2, P2 + R1, P3 + R0)라서 max(6, 6, 8) = 8
R4는 위의 값들로부터 max(9, 10, 9, 9) = 10

위의 과정에서 R1, R2, R3는 계속해서 나오기 때문에 이 값들을 저장해 두고 재사용하면 일일히 재계산하지 않아도  됩니다
여기서 Top-down으로 불리는 **메모이제이션**을 사용할 수도 있고, Bottom-up이라 불리는 **상향식 계산법**을 사용할 수도 있습니다.



### 최장 공통 부분 수열 (LCS)

두개의 문자열에서 순서대로 겹치는 문자가 최대 몇개인지 구하는 문제

ex) ABCBDAB, BDCABA => LCS는 BCAB , BDAB, BCBA

LCS(i,j)는 문자열 i, j의 LCS 길이라고 했을 때,
마지막 두문자가 같다면 LCS(i,j) = LCS(i-1,j-1)+1 과 같다. LCS(ABCBDAB, BDCAB) = LCS(ABCBDA, BDCA) + 1
마지막 두문자가 다르다면 LCS(i,j) = max(LCS(i,j-1), LCS(i-1,j))가 된다. LCS(ABCBDAB, BDCABA)는 LCS(ABCBDA, BDCABA)와 LCS(ABCBDAB, DBCAB) 중 더 큰 값

이렇게 끝부분부터 비교해 하나씩 줄여가면 LCS의 길이가 나오게 됩니다

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        System.out.println(LCS("ABCBDAB".toCharArray(), "BDCABA".toCharArray()));
    }

    private static int LCS(char[] x, char[] y){
        int l1 = x.length;
        int l2 = y.length;
        int[][] dp = new int[l1+1][l2+1];

        for (int i = 0; i <= l1 ; i++) {
            for (int j = 0; j <= l2; j++) {
                if(i==0 || j==0) dp[i][j] = 0;
                else if(x[i-1]==y[j-1]) //마지막 두문자 비교, 같다면
                    dp[i][j] = dp[i-1][j-1]+1;
                else //마지막 두 문자가 다르다면
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[l1][l2];
    }
}
```



### 0/1 배낭문제

무게 제한이 50인 배낭에 다음과 같은 세개의 물건을 넣는 문제
넣은 물건들의 가치(v) 합이 최대가 되는 값을 구하면 됨

문제 이름이 0/1인 이유는 물건을 쪼개서 넣지 못하고, 선택지가 통째로 넣거나, 아예 넣지 않거나 두개밖에 없기 때문

| i    | 1    | 2    | 3    |
| ---- | ---- | ---- | ---- |
| vi   | 60   | 100  | 120  |
| wi   | 10   | 20   | 30   |

DP[i,w] = 물건 1\~i까지만 고려하고, (임시) 배낭의 용량이 w일때의 최대 가치 (단 i=1\~n, w = 1\~W)

```
배낭의 용량 W
n개의 물건과 각 물건 i의 무게 wi와 가치 vi, 단 i= 1~n
dp[n,W]

FOR i IN 0 → n : dp[i,0] ← 0
FOR w IN 0 → W : dp[0,w] ← 0

FOR i in 1 → n
	FOR w in 1 → W
		IF wi > w
			dp[i,w] ← dp[i-1,w]
		ELSE
			dp[i,w] ← max(vi + dp[i-1,w-wi], k[i-1,w])
			
RETURN dp[n,W]
```



>  참고 사이트 1 : https://www.zerocho.com/category/Algorithm/post/584b979a580277001862f182

> 참고 사이트 2 : https://skmouse.tistory.com/entry/DP%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DDynamic-Programming-%EC%8B%AC%ED%99%94

> 참고 사이트 3 : https://velog.io/@gillog/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming

