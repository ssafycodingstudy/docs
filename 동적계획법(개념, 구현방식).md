## 동적계획법 (Dynamic Programming)

___

### DP란?

: 하나의 문제를 여러 하위 문제로 나누어 풀고, 그것들을 결합해서 최종 목적에 도달하는 방식의 알고리즘

대표예제 - 피보나치 수열

### 메모이제이션

: 동일한 문제를 반복해야 할 경우, 한 번 계산된 결과를 메모리 공간에 저장해두었다가 활용하는 방식(중복 계산을 줄임)

### 조건

1. 최적 부분구조 

   : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다

2. 중복되는 부분 문제

   : 동일한 작은 문제를 반복적으로 해결해야 한다

## 구현방식

### Top-down(하향식)

- 문제 풀이가 위에서 아래로 진행되는 것을 의미
- 구현 과정에서 재귀함수를 이용
- 작은 문제들을 재귀적으로 호출하여 모두 호출되었을때 큰값의 결과가 나온다

```
int fiboData[100] = {0};

int fibo(int n)
{
  if (n<=2) 
    return 1;
  if (fiboData[n]==0)
    fiboData[n] = fibo(n-1) + fibo(n-2);
  return fiboData[n];
}
```

### Bottom-Up(상향식)

- 문제 풀이가 **결과값을 저장하여** 아래에서 위로 진행되는 것을 의미
- 동적 계획법의 전형적인 형태(**결과 저장용 리스트(배열) = DP 테이블**)

```
int fibo(int n)
{
  fibodata[0] = 0;
  fiboData[1] = 1;
  for (int i=2; i<=n; i++)
    fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
  return fiboData[n];
}
```

###  장단점

- 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식
- 한번 사용된 결과값을 반복적으로 호출한다
- 그리디 알고리즘
  - 모든 해를 구하지 않고 순간순간 최적의 해를 찾는 방식
  - 그리디 알고리즘으로 도출된 값이 항상 최적의 해라고 할 수 없다
- 분할정복
  - 한번 분할이 이루어진 뒤에 해당 피벗을 다시 처리하는 부분문제는 호출하지 않는다
- 동적 계획법은 그리디 알고리즘에 비해 시간이 걸리지만, 결과적으로 항상 효율적인 값을 구할 수 있다