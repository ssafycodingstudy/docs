# 정렬 알고리즘

* 정렬이란 대소 관계에 따라 데이터 집합을 일정 순서로 바꾸어 늘어 놓는 작업. 

* 기본적으로 오름차순(ascending)과 내림차순(descending) 정렬이 있음.



#### 알고리즘의 안정성

* 안정적인 알고리즘, 비안정적인 알고리즘으로 나눌 수 있음.

* 안정적인 알고리즘이란 값이 같은 원소의 순서가 정렬 후에도 그대로 유지되는 것을 뜻함.

  

#### 1. 버블 정렬

* 이웃한 두 원소의 대소 관계를 비교하여 필요에 다라 교환을 반복하는 알고리즘
* 단순 교환 정렬 이라고도 함
* 비교 교환을 반복하는 일련의 과정을 패스 라고 함
* 장점
  * 구현이 매우 간단함
  * 데이터를 하나씩 정밀 비교가 가능
* 단점
  * 교환이 이동보다 더 복잡해 효율성이 떨어짐
  * 시간복잡도가 항상 O(N^2)

![1  버블정렬](https://user-images.githubusercontent.com/44665707/129041082-1019f1b6-a480-4d80-a7a0-cbd341de1380.png)


#### 2.  단순 선택 정렬

* 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하는 알고리즘
* 과정
  * 아직 정렬하지 않은 부분에서 값이 가장 작은 원소를 선택
  * 해당 원소와 아직 정렬하지 않은 부분에서 맨 앞에 있는 원소를 교환
* 장점
  * 교환 횟수가 적어 교환이 많이 이루어져야 하는 상태에서는 효율적으로 사용 가능
* 단점
  * 이미 정렬된 상태에 자료가 추가되면 재정렬할 때 최악의 처리 속도가 나올수 있음
  * 비안정적인 알고리즘


![2  단순 선택정렬](https://user-images.githubusercontent.com/44665707/129041154-4ffe5d45-b865-4b6c-a80b-02b68a9ca78f.png)



#### 3. 단순 삽입 정렬

* 주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘
* 선택 정렬과 비슷해 보이지만 최소값을 선택하지 않는다는 점이 다름
* 장점
  * 최선의 경우 빠른 효율성. 크기가 적은 데이터 집합을 정렬할 때 효율이 좋음
* 단점
  * 데이터 크기가 크면 비효율적. 

![3  단순 삽입 정렬](https://user-images.githubusercontent.com/44665707/129041192-19d014e7-b2d0-4aa6-b634-449b637e4b54.png)



#### 4. 셸 정렬

* 단순 삽입정렬의 장점은 살리고 단점을 보완해 더 빠르게 정렬하는 알고리즘
* 정렬할 배열의 원소를 그룹으로 나눠 각 그룹별로 수행, 그 후 정렬된 그룹을 합치는 작업 반복
* 그룹을 나누는 간격에 따라 효율성이 갈림. 배수가 되지 않도록 조정하는것이 좋음.

![4  셸 정렬](https://user-images.githubusercontent.com/44665707/129041228-cd01c138-5dff-4e60-a377-b608dbf4d8f3.png)



#### 5. 퀵정렬

* 이름 그대로 가장 빠른 알고리즘으로 알려져 있으며 널리 사용
* 피벗을 결정하여 배열을 두 그룹으로 나누기를 반복
* 왼쪽은 피벗 미만, 오른쪽은 피벗 이상으로 계속 정렬
* 
![5  퀵정렬 사진](https://user-images.githubusercontent.com/44665707/129041272-f269cdaf-c881-412c-a3b4-28614abcaf77.png)



#### 6. 병합 정렬

* 배열을 앞, 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘
* 분할한 후, 그 안에서 정렬하고 각 리스트의 맨앞의 값들을 비교해 작은 숫자부터 차례로 채움

![6  병합 정렬](https://user-images.githubusercontent.com/44665707/129041324-b2175e00-1aa7-485e-a198-78a01e8dfbbf.png)



#### 7. 힙 정렬

* 힙은 부모-자식의 대소관계가 일정하다는 조건을 만족하는 완전 이진 트리
* 힙 정렬은 힙에서 최댓값(최솟값)은 루트에 위치한다는 특징을 이용해 정렬함
* 배열을 힙으로 만들고, 0번 인덱스의 최댓값을 마지막 원소와 교환. 나머지 부분에 대해서 반복

![7  힙 정렬](https://user-images.githubusercontent.com/44665707/129041354-2e4b6fff-5e25-45a6-8b79-1813b86a4541.png)
